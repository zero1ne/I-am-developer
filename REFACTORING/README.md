## 소프트웨어 장인: 프로페셔널리즘, 실용주의, 자부심

### CHAPTER 01 : 리팩터링, 첫 번째 예시
- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
- 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.
- 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
- 좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가이다.
- 리팩터링하는 리듬을 짧게 가져가라 → 단계를 잘게 나누어야한다.

### CHAPTER 02 : 리팩터링 원칙
- Refactoring : 소프트웨어의 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩토링을 진행하면, 소프트웨어 설계가 좋아진다 → 소프트웨어를 이해하기 쉬워지고 버그를 쉽게 찾을 수 있다 → 개발 속도를 높일 수 있다.
- 준비를 위한 리팩터링 : 버그가 발생할 가능성을 줄이고 기능을 쉽게 추가하게 만들어준다
- 이해를 위한 리팩터링 : 보이지 않는 코드와 설계가 보이며, 비효율적인 코드를 정리하게 해준다.
- 각각의 작은 단계가 코드를 깨뜨려서는 안된다.
- 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야한다.
- 굳이 수정을 해야하지 않거나, 처음부터 새로작성하는게 더 쉽다면 리팩터링하지 않는다.
- Continous Integration : 기능을 잘게 쪼개고, 기능을 토글할 수 있게 하자 → 짧은 통합 주기를 통해 리팩터링을 수행하기 쉬워진다.
- Testing : 프로그램의 동작을 같게 유지하는데 도움을 준다.
- YAGNI(You aren't going to need it) : 당장에 필요한 기능만으로 최대한 간결하게 만들어라 → TDD(Test code + Refactoring)와 CI를 통해 애자일의 이점을 취할 수 있다
- 성능 개선 : 대부분 프로그램은 코드 중 극히 일부에서 대부분의 시간을 소비한다 → 시간과 공간을 많이 잡아먹는 지점을 알아내서 개선하는 것이 큰 도움이 된다.

### CHAPTER 03 : 코드에서 나는 악취
- Mysterious Name : 이름은 단순하고 명료해야한다 → 마땅한 이름이 떠오르지 않는다면 근본적인 문제가 숨어 있을 가능성이 높다
- Duplicated Code : 비슷한 코드는 코드의 수정을 방해한다.
- Long Function : 주석을 달아야할 부분은 함수로 만들고 적당한 이름을 지어야한다 → 무엇을 하는지 쉽게 보여야 한다.
- Long Parameter List : 객체를 통째로 넘기거나, 클래스로 묶어 매개변수를 제거해야 한다. 
- Global Data : 어디서 사용되는지 파악하기 어려워 진다.
- Mutable Data : 필요한 곳에서만 값이 수정될 수 있도록 캡슐화 하거나 불변성을 적용한다.
- Divergent Change : 하나의 모듈이 하나의 책임을 가지게 하여야 한다
- Shotgun Surgery : 함께 변경되는 대상이 나뉘어져 있다면 묶어야 한다.
- Feature Envy : 코드 영역 안에서 이뤄지는 상호작용은 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄인다.
- Data Clumps : 같이 사용되는 데이터는 하나로 묶어 주어야 한다.
- Primitive Obsession : 기본형을 보다 의미있는 형태로 바꾸어야 한다
- Repeated Switches : 다형성을 이용하도록 전환하여야 한다.
- Loops : 필요하다면 일급 함수를 통해간결하게 수정한다.
- Lazy Element : 필요치 않게 요소화 되어있다면 다시 역으로 합쳐야 한다.
- Speculative Generality : 실제 사용하지 않는 죽은 코드는 제거하여야 한다.
- Temporary Field : 특정 상황에서만 값이 채워지는 값의 경우 분리하여야 한다.
- Message Chains : 객체를 연속으로 요청하는 경우는 숨겨야 한다.
- Middle Man : 객체가 지나치게 위임을 사용하고 있다면 실제 일을 하는 객체와 소통하게 하자.
- Insider Trading : 모듈 간의 데이터 이동을 명확하게 드러내야한다.
- Large Class : 클래스 내부의 중복을 제거하고 필요한 부분
- Alternative Classes with Different Interfaces : 다른 동작으로 교체하기 위해 메서드 시그니처를 일치하거나 슈퍼클래스로 추출한다.
- Data Class : 값을 일관성 있게 유지하기 위해 세터를 제거하거나, 필요한 클래스로 병합하는 걸 생각해 본다.
- Refused Bequest : 인터페이스를 따르고 싶지 않다면 상속이 불필요한지 생각해 본다.
- Comments : 주석을 남기기 보다는 주석이 필요 없는 코드로 바꿀 수 있는지 생각해 본다.

### CHAPTER 04 : 테스트 구축하기
- 테스트를 자동화하고 결과까지 체크하도록 하자 → 버그를 찾는 시간을 대폭 줄여줄 수 있다.
- 완벽하게 만드느라 테스트를 수행하지 못하느니, 불완전한 테스트라도 작성해 실행하는게 낫다.
- 문제가 생길 수 있는 경계 조건을 생각해보고 그 부분을 집중적으로 테스트하자.
- 버그 리포트를 받으면 버그를 드러내는 단위 테스트부터 작성하자.
