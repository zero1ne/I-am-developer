## 내가 알았던 객체지향 이란
- 객체 간의 상호작용을 통해 작동하는 프로그램을 만드는 Paradigm
- 잘 만들어진 객체지향이란 → 객체간의 책임이 뚜렷하고, 경계가 명확하며, 일관성 있는 의존성을 가져야한다.

#### 성질
- Abstraction : 객체에서 행위(Method)와 속성(Property)를 추출하는 것
- Encapsulation : 객체에 변수와 함수를 묶는 것
- Inheritance : 부모 객체의 속성을 자식에게 물려 주는 것
- Polymorphism : 같은 이름이지만 다른 행동을 하는 것 → Overriding / Overloading

#### Q/A
Q. Overriding / Overloading 시에 Return 값은 어떻게 되어야하는가?  
A. Overriding 시에는 무조건 같아야 하고, Overloading 시에는 다를 수도 있다. Calculator의 Add(int, int) -> int 를 생각해보면 쉽게 이해할 수 있을 듯

#### 잘 설계하기 위해서는 → SOILD
- Single Responsibility : 객체는 단 한가지일만 수행하여야 한다
- Open-Closed : 인터페이스 등을 사용하여 기존의 코드를 변경하지 않으면서 추가할 수 있도록 하여야 한다.
- Liskov Substituition : 자식은 부모가 하는 행동을 수행할 수 있어야 한다.
- Interface Segregation : 인터페이스는 작고 구체적이야 한다.
- Dependency Inversion : 객체간의 의존관계는 원칙을 가지고 있어야 한다.

## Objects : 코드로 이해하는 객체지향 설계

### 1장 : 객체, 설계
1. 티켓 판매 애플리케이션
#### Requirement
- 관람객은 초대장/현금/티켓을 가지고 있는 가방을 가지고 있다
- 매표소에서 초대장을 티켓으로 교환하거나 구매한다. → 티켓과 티켓의 판매금액을 보관한다.
- 판매원은 초대장을 티켓으로 교환하거나 돈을 받고 티켓을 판매한다.

#### Code
- 작성 시간이 너무 많이 걸림(약 4시간) - 코드를 많이 작성해 보지 않아서 그렇지 않을까?

2. 무엇이 문제인가 / ...
- 잘 작동하고, 변경이 용이해야 하며, 이해하기 쉬운 코드가 만들어져야 한다.
- 변경에 취약한 이유 → 객체 사이에 불필요한 의존성(Dependency)이 있는 것, 결합도(Coupling)를 낮추어야 한다
- 객체의 자율성을 높여야 한다 → 객체가 자신을 스스로 책임 질 수 있도록 캡슐화를 적용한다.
- 현실에서 수동적일지라도 객체 지향에서는 모든 객체가 능동적이여야 한다. → 의인화(anthropomorphism)
- 설계는 항상 **Trade-Off** 라는 것을 명심하자.

### 2장 : 객체지향 프로그래밍
1. 영화 예매 시스템
#### Requirement
- 영화는 영화에 대한 기본 정보(제목, 상영시간, 가격정보, etc)를 가지고 있다. 
- 상영은 실제로 관객들이 영화를 관람하는 사건을 표현한다.
- 할인 조건은 가격의 할인 여부를 결정하며, 순서 조건과 기간 조건의 두 종류로 나눌 수 있다 → 여러개의 조건을 적용할 수 있음(OR)
- 할인 정책은 가격의 할인 요금을 결정하며, 금액 할인 정책과 비율 할인 정책이 있다 → 영화별로 하나의 할인 정책만 가능
- 예매완료시 제목, 상영정보, 인원, 정가, 결제 금액을 포함한 예매 정보를 생성

#### Code
- 유연성이 떨어지는 것처럼 느껴짐 

2. 객체 지향 프로그래밍을 향해 / ...
- 도메인을 구성하는 개념과 관계를 표현 → 할인 정책이 있는 경우에만 조건이 있다는 것을 파악할 수 있다
- 객체간의 상호작용을 위해 메시지를 전송하고 수신하는 부분이 필요
- **Template Pattern** : 부모클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 것 
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다 → 코드가 유연성이 높아지지만 이해하기 어려워진다.
- 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
- **Polymorphism** : 동일한 메세지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력(실제 어떤 메소드가 실행되는가)
- 상속 → 캡슐화를 위반하고 설계를 유연하지 못하게 할 수 있다, 합성 → 메시지를 통해 느슨하게 연결되므로 조금 더 선호됨

### 3장 : 역할, 책임, 협력
1. 협력
- 협력 : 객체가 기능을 구현하기 위해 수행하는 상호작용
- 메시지 전송을 통해 다른 객체와 커뮤니케이션 → 객체의 행동을 결정
- 객체를 설계하는 데 필요한 문맥(context)를 제공해 줌

2. 책임
- 책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합
- '하는 것'과 '아는 것' → 객체에 책임을 할당하기 위한 가장 기본적인 원칙
- **Information Expert Pattern** : 책임을 수행하는데 필요한 정보를 가장 잘 알고 있는 전문가에게 책임을 할당하는 것 → Responsibility Driven Design 
- 메시지가 객체를 결정 : 객체가 최소한의 인터페이스(mininal interface), 충분히 추상적인 인터페이스(abstract interface)를 가지게 됨
- 행동이 상태를 결정 : 협력이 행동을 결정하고 행동이 상태를 결정한다 → Data Drivien Design

3. 역할
- 역할 : 객체가 특정한 협력 안에서 수행하는 책임의 집합
- 유연하고 재사용 가능한 협력 → Abstraction

### 4장 : 설계 품질과 트레이드 오프
1. 데이터 중심의 영화 예매 시스템 / ...
- 데이터(상태)에 초점을 맞추는 설계는 변경에 취약하다
- **Encapsulation** : 변경될 수 있는 어떤 것(구현)이라도 캡슐화 하여야 한다.
- **Cohesion** : 모듈의 내부 요소들이 연관되어 있는 정도 → 객체에 얼마나 관련 높은 책임(**SRP**)을 할당했는가?
- 변경의 관점에서 : 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도
- **Coupling** : 의존성의 정도 → 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는가?
- 변경의 관점에서 : 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도 → **인터페이스**에 의존하게 하여야 낮은 결합도를 얻을 수 있다.
- 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 결정하며, 객체를 고립시킨채 오퍼레이션을 결정 → 본질적으로 캡슐화 위반, 낮은 응집도, 높은 결합도가 발생하기 쉽다.

### 5장 : 책임 할당하기
1. 책임 주도 설계를 향해
- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라 : 메시지를 전송해야 하는 데 누구에게 전송하지?

2. 책임 할당을 위한 GRASP(General Reqsponsibility Assignment Software Pattern) Pattern
- 3.2. Information Expert Pattern : 정보 전문가에게 책임을 할당하라
- **Low Coupling Pattern** / **High Cohesion Pattern** : 낮은 결합도, 높은 응집도의 설계
- **Creator Pattern** : 생성될 객체에 대해 잘 알거나 사용해야하는 객체, 즉 결합된 객체에 인스턴스를 생성할 책임을 할당

3. 구현을 통한 검증
- 인스턴스 변수가 함께 초기화 되는 속성을 기준으로 코드를 분리해야 한다.
- 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.
- **Polymorphism Pattern** : 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 타입의 책임으로 할당한다.
- **Protected Variations Pattern** : 변하지 않는 인터페이스 뒤로 변경을 캡슐화 한다.

4. 책임 주도 설계의 대안
- 책임을 어디에 두어야하는지 결정하기 어렵다 → Refactoring 을 통해 해결할 수 있다.
- 메서드를 응집도 있는 수준으로 분해 → 객체를 자율적으로 만들기 위해 메서드를 적절한 위치(일반적으로는 인자에 정의된 클래스 중 하나)로 이동한다.

### 6장 : 메시지와 인터페이스
1. 협력과 메시지
- 메시지 전송 : 오퍼레이션명(Operation name), 인자(argument), 메시지 수신자(Receiver)로 구성 → 객체들이 협력하기 위한 유일한 의사소통 수단
- 메서드 : 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 퍼블릭 인터페이스 : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지
- 시그니처 : 오퍼레이션이나 메서드의 이름과 파라미터 목록

2. 인터페이스와 설계 품질 / ...
- 디미터 법칙 : 객체의 내부 구조에 강하게 결합되지 않도록 협력경로를 제한하라 → 여러개의 도트를 사용한 코드가 객체의 내부 구조를 노출하는가?
- 묻지말고 시켜라 : 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들어라 → 응집도와 결합도에 따라 때로는 물어보아라
- 명령-쿼리 분리(Command-Query Seperation) 원칙 → 객체 지향에서는 부수효과를 기반으로 한다. 
  - 객체의 상태를 변경하는 명령(프로시저)는 반환값을 가질 수 없다.
  - 객체의 정보를 반환하는 쿼리(함수)는 상태를 변경할 수 없다.
- 의도를 드러내는 인터페이스

#### 7장 : 객체 분해
1. ... / 프로시저 추상화와 기능 분해
- 프로시저 추상화 → 기능 분해(Functional Decompostion) : 하향식 접근법(Top-Down Approach)
- 하나의 메인 함수라는 비현실적인 아이디어 : 하나의 알고리즘이나 배치 처리를 구현하기에는 적합
- 메인 함수의 빈번한 재설계 / 비즈니스 로직과 사용자 인터페이스의 결합 
- 성급하게 결정된 실행 순서 : 다른 함수와 시간적으로 강하게 결합되어있다 → 높은 결합도
- 데이터 변경으로 인한 파급효과 : 변경에 대한 영향을 최소화하기 위해 영향을 받는 부분과 아닌 부분을 분리해야한다 → 정보 은닉과 모듈의 필요성

2. 모듈
- 정보 은닉(Information Hiding) : 모듈은 데이터와 함수가 통합된 한차원 높은 추상화를 제공할 수 있음 → 인스턴스의 개념 부재
  - 복잡성 : 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공하여 복잡도를 낮춤
  - 변경 기능성 : 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공

3. 데이터 추상화와 추상 데이터 타입
- 데이터 추상화 → 타입 추상화(Type Abstraction) : 추상 데이터 타입(Abstract Data Type)
- 타입 정의 선언 / 인스턴스를 다루기 위한 오퍼레이션의 집합 / 오퍼레이션을 통해서만 조작할 수 있도록 데이터 보호 / 여러개의 인스턴스 생성 가능

4. 클래스
- 객체 기반 프로그래밍(Object-Based Programming) : 상속과 다형성이 존재하지 않음
- 데이터 추상화 → 프로시저 추상화(Procedure Abstraction) : 객체지향(Object-Oriented)
- 객체 지향은 타입을 기준으로 오퍼레이션을 묶는다 → 절차 추상화(Procedural Abstraction)
- 타입 변수를 이용한 조건문을 다형성으로 대체 → 기존 코드에 영향을 미치지 않고 새로운 객체 유형과 행위를 추가 : **개방-폐쇄 원칙(Open-Closed Principle)**
- 타입 추가가 빈번하다면 객체 지향을, 오퍼레이션 추가가 빈번하다면 추상 데이터 타입을 사용하라
